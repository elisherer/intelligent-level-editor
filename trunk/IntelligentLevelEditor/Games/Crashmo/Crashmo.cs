using System;
using System.Drawing.Imaging;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using IntelligentLevelEditor.Properties;

namespace IntelligentLevelEditor.Games.Crashmo
{
    public class Crashmo
    {
        public enum PosType : byte
        {
            Flag = 1,
            Manhole = 2,
            Switch = 3,
            Door = 4,
            Cloud = 5
        }

        public enum SwitchDirection : byte
        {
            Right = 0,
            Left = 1,
            Down = 4,
            Up = 5
        }

        public enum CrashmoFlags : uint //TODO: Flags
        {
            Constant = 0x001,
            Large = 0x002
        }

        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        public struct CrashmoPosition
        {
            public ushort Xy; // x = bits 12..16 , y = bits 7..11 *negated*
            public byte Type; // 1 = flag, 2 = manhole, 3 = switch, 4 = door, 5 = cloud
            public byte Flags;
            // for manholes & doors it's the color 0=red, 1=yellow...
            // for switches it's the direction (0=right, 1=left, 4=down, 5=up).
            // for flag & clouds it's nothing
        }

        public const int BitmapSize = 32;
        public const int CrashmoColorPaletteSize = 184;
        public static readonly ColorPalette CrashmoColorPalette;

        static Crashmo()
        {
            CrashmoColorPalette = Resources.pushmoPalette.Palette;
        }

        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        public struct CrashmoQrData
        {
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
            public byte[] Magic; //MTUA

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
            public byte[] CustomCrc32;

            public uint Unknown1; // = 7

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 0x10)]
            public byte[] Zeros0;

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 0x16)]
            public byte[] Author;

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 0x22)]
            public byte[] LevelName;

            public byte Zero1; // ??

            public uint Difficulty;

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 7)]
            public byte[] Unknown3; // = 04 2C 09 20 01 00 00

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 10)]
            public byte[] PaletteData;

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 6)]
            public byte[] Zeros2;

            public uint UtilitiesLength;

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 0x16)] //in the flag - size 2=16x16 3=32x32 ??
            public CrashmoPosition[] Utilities;

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 0x200)]
            public byte[] LevelData;

            public byte Protection; // 4-locked 3-open
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 3)]
            public byte[] Footer; // = FAFF0F
        } //4+4+4+0x10+0x16+0x22+1+4+7+10+6+4+4+21*4+0x200+1+3 = 720 bytes

        public static bool IsMatchingData(byte[] data)
        {
            return (data[0] == 0xAD && data[1] == 0x0A);
        }

        public static byte[][] Decode(byte[] levelData)
        {
            //prepare a 2D array
            var bmp = new byte[BitmapSize][];
            for (var i = 0; i < bmp.Length; i++)
                bmp[i] = new byte[BitmapSize];
            var two = 0;
            for (var y = BitmapSize - 1; y >= 0; y--)
                for (var x = 0; x < BitmapSize; x += 2, two++)
                {
                    bmp[y][x] = (byte) (levelData[two] >> 4);
                    bmp[y][x+1] = (byte) (levelData[two] & 0xf);
                }
            return bmp;
        }

        public static byte[] Encode(byte[][] bmp)
        {
            var mem = new MemoryStream();
            for (var y = BitmapSize - 1; y >= 0 ; y--)
                for (var x = 0; x < BitmapSize; x += 2)
                    mem.WriteByte((byte)((bmp[y][x] << 4) + bmp[y][x+1]));
            return mem.ToArray();
        }

        public static CrashmoQrData ReadFromByteArray(byte[] array)
        {
            //The file start with 0xAD0A and then an uint32 and an lz10 compressed blob

            if (array[0] != 0xAD || array[1] != 0x0A)
                throw new Exception("Corrupt crashmo binary!");

            var ins = new MemoryStream(array);
            var fourBytes = new byte[4];
            ins.Read(fourBytes, 0, 4);
            if (array[0] != 0xAD || array[1] != 0x0A || array[2] != 0 || array[3] != 0)
                throw new Exception("Corrupt crashmo binary!");
            ins.Read(fourBytes, 0, 4);
            var version = BitConverter.ToUInt32(fourBytes,0);
            if (version != 1)
                throw new Exception("Unsupported level version!");
            
            ins.Read(fourBytes, 0, 4);
            var compressedSize = BitConverter.ToUInt32(fourBytes, 0);

            var decompressed = new byte[Marshal.SizeOf(typeof(CrashmoQrData))];
            var ms = new MemoryStream(decompressed);

            var lz10 = new DSDecmp.Formats.Nitro.LZ10();
            try
            {
                lz10.Decompress(ins, compressedSize, ms);
            }
            catch//(Exception ex)
            { }

            ms.Close();  

            return MarshalUtil.ByteArrayToStructure<CrashmoQrData>(decompressed);
        }

        public static CrashmoQrData EmptyCrashmoData()
        {
            var dummyArray = new byte[Marshal.SizeOf(typeof(CrashmoQrData))];
            var pd = MarshalUtil.ByteArrayToStructure<CrashmoQrData>(dummyArray);

            Buffer.BlockCopy(
                new [] { (byte)'M', (byte)'T', (byte)'U', (byte)'A' }, 
                0, pd.Magic, 0, 4);
            pd.Unknown1 = 0x07; //Always 7

            var authorBytes = Encoding.Unicode.GetBytes("NoBody");
            Buffer.BlockCopy(authorBytes, 0, pd.Author, 0, authorBytes.Length);
            var nameBytes = Encoding.Unicode.GetBytes("NoName");
            Buffer.BlockCopy(nameBytes, 0, pd.LevelName, 0, nameBytes.Length);
            
            pd.Difficulty = 1;
            Buffer.BlockCopy(
                new byte[] { 0x04, 0x2C, 0x09, 0x20, 0x01, 0x00, 0x00 },
                0,pd.Unknown3,0,pd.Unknown3.Length);
            Buffer.BlockCopy(
                new byte[] { 0x1F, 0x20, 0x77, 0x21, 0x3D, 0x2A, 0x2E, 0x23, 0x51, 0x1C },
                0, pd.PaletteData, 0, pd.PaletteData.Length);

            pd.Protection = 3;
            pd.Footer[0] = 0xFA; pd.Footer[1] = 0xFF; pd.Footer[2] = 0x0F;
            return pd;
        }

        //Found by me: elisherer :)
        public static byte[] CustomCrc32(byte[] data, int start, int len)
        {
            const ulong poly = 0x04C11DB7;
            const ulong xorout = 0x45B54367;
            ulong crc = 0;

            for (var i = start; i < start + len; i++)
            {
                var temp = (((crc >> 24) ^ data[i]) & 0xFF) << 24;
                for (var j = 0; j < 8; j++)
                    temp = (temp & 0x80000000) > 0 ? (temp << 1) ^ poly : temp << 1;
                crc = (crc << 8) ^ temp;
            }

            return BitConverter.GetBytes(crc ^ xorout);
        }

        public static readonly byte[] EmptyQrData =
        {
            0xAD, 0x0A, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xB4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0xF4, 0xFA, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFB, 0xFF, 0x0F, 0x00, 0xFB, 0xFF, 0x0F, 
            0x00, 0x00, 0x00, 0x00, 0x0C, 0xFB, 0xFF, 0x0F, 0x0C, 0xFB, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 
            0x18, 0xFB, 0xFF, 0x0F, 0x18, 0xFB, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x24, 0xFB, 0xFF, 0x0F, 
            0x24, 0xFB, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x30, 0xFB, 0xFF, 0x0F, 0x30, 0xFB, 0xFF, 0x0F, 
            0x00, 0x00, 0x00, 0x00, 0x3C, 0xFB, 0xFF, 0x0F, 0x3C, 0xFB, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 
            0x48, 0xFB, 0xFF, 0x0F, 0x48, 0xFB, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x54, 0xFB, 0xFF, 0x0F, 
            0x54, 0xFB, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x60, 0xFB, 0xFF, 0x0F, 0x60, 0xFB, 0xFF, 0x0F, 
            0x00, 0x00, 0x00, 0x00, 0x6C, 0xFB, 0xFF, 0x0F, 0x6C, 0xFB, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 
            0x78, 0xFB, 0xFF, 0x0F, 0x78, 0xFB, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x84, 0xFB, 0xFF, 0x0F, 
            0x84, 0xFB, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x90, 0xFB, 0xFF, 0x0F, 0x90, 0xFB, 0xFF, 0x0F, 
            0x00, 0x00, 0x00, 0x00, 0x9C, 0xFB, 0xFF, 0x0F, 0x9C, 0xFB, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 
            0xA8, 0xFB, 0xFF, 0x0F, 0xA8, 0xFB, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xB4, 0xFB, 0xFF, 0x0F, 
            0xB4, 0xFB, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xFB, 0xFF, 0x0F, 0xC0, 0xFB, 0xFF, 0x0F, 
            0x00, 0x00, 0x00, 0x00, 0xCC, 0xFB, 0xFF, 0x0F, 0xCC, 0xFB, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 
            0xD8, 0xFB, 0xFF, 0x0F, 0xD8, 0xFB, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xE4, 0xFB, 0xFF, 0x0F, 
            0xE4, 0xFB, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFB, 0xFF, 0x0F, 0xF0, 0xFB, 0xFF, 0x0F, 
            0x00, 0x00, 0x00, 0x00, 0xFC, 0xFB, 0xFF, 0x0F, 0xFC, 0xFB, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 
            0x08, 0xFC, 0xFF, 0x0F, 0x08, 0xFC, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x14, 0xFC, 0xFF, 0x0F, 
            0x14, 0xFC, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x20, 0xFC, 0xFF, 0x0F, 0x20, 0xFC, 0xFF, 0x0F, 
            0x00, 0x00, 0x00, 0x00, 0x2C, 0xFC, 0xFF, 0x0F, 0x2C, 0xFC, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 
            0x38, 0xFC, 0xFF, 0x0F, 0x38, 0xFC, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x44, 0xFC, 0xFF, 0x0F, 
            0x44, 0xFC, 0xFF, 0x0F, 0x78, 0xFC, 0xFF, 0x0F, 0x58, 0x20, 0x22, 0x14, 0x34, 0x85, 0x77, 0x14, 
            0x68, 0xFD, 0xFF, 0x0F, 0xDC, 0xF0, 0x02, 0x08, 0x8C, 0xEE, 0x02, 0x08, 0x20, 0x85, 0x12, 0x00, 
            0xDC, 0xF0, 0x02, 0x08, 0x00, 0x00, 0x00, 0x00, 0x34, 0x85, 0x77, 0x14, 0xA0, 0xFC, 0xFF, 0x0F, 
            0x58, 0x20, 0x22, 0x14, 0x34, 0x85, 0x77, 0x14, 0x68, 0xFD, 0xFF, 0x0F, 0xE0, 0x86, 0x77, 0x14, 
            0x8C, 0xEE, 0x02, 0x08, 0x20, 0x85, 0x12, 0x00, 0x38, 0x85, 0x77, 0x14, 0x20, 0xFD, 0xFF, 0x0F, 
            0x34, 0x85, 0x77, 0x14, 0x44, 0xCD, 0x1E, 0x00, 0xFC, 0xF7, 0x34, 0x00, 0x40, 0xFD, 0xFF, 0x0F, 
            0x02, 0x00, 0x00, 0x00, 0xB8, 0x14, 0x23, 0x14, 0x40, 0xFD, 0xFF, 0x0F, 0x78, 0xFD, 0xFF, 0x0F, 
            0xB8, 0x14, 0x23, 0x14, 0xFC, 0xF7, 0x34, 0x00, 0xC8, 0xFD, 0xFF, 0x0F, 0x2C, 0x3F, 0x19, 0x00, 
            0xA0, 0x61, 0x77, 0x14, 0xE8, 0x61, 0x77, 0x14, 0x28, 0x68, 0x77, 0x14, 0xB8, 0x14, 0x23, 0x14, 
            0x10, 0xF0, 0x02, 0x08, 0x10, 0xFD, 0xFF, 0x0F, 0x00, 0xFE, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 
            0xC8, 0xFD, 0xFF, 0x0F, 0x88, 0x19, 0x19, 0x00, 0xDC, 0xF0, 0x02, 0x08, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x03, 0x60, 0x75, 0x77, 0x14, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 
        } ;

    }
}
